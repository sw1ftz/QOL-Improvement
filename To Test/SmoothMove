local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

local maxRenderDistance = 500 -- Optional: Ignore super far objects (for performance)

local smoothParts = {}

-- Function to check if a part should be smoothed
local function shouldSmoothPart(part)
    return part:IsA("BasePart") and not part.Anchored
end

-- Function to add part to the smoothing list
local function addPart(part)
    if shouldSmoothPart(part) then
        smoothParts[part] = true
    end
end

-- Function to remove destroyed part
local function removePart(part)
    smoothParts[part] = nil
end

-- Initial scan of the workspace
for _, part in ipairs(workspace:GetDescendants()) do
    addPart(part)
end

-- Listen for new parts (anything added dynamically)
workspace.DescendantAdded:Connect(addPart)
workspace.DescendantRemoving:Connect(removePart)

-- Helper: Check if part is close enough to render
local function isWithinRenderDistance(part)
    if not character or not character.PrimaryPart then
        return true -- If player doesn't exist, allow all parts (edge case for very early loads)
    end

    local distance = (part.Position - character.PrimaryPart.Position).Magnitude
    return distance <= maxRenderDistance
end

-- Apply GetRenderCFrame smoothing every frame
RunService.RenderStepped:Connect(function()
    for part in pairs(smoothParts) do
        if part.Parent and isWithinRenderDistance(part) then
            local smoothCFrame = part:GetRenderCFrame()
            part.CFrame = smoothCFrame
        else
            smoothParts[part] = nil
        end
    end
end)
